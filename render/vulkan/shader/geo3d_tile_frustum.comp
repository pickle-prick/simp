#version 450

// NOTE(k): it's easier for the local group size to match the size of the tile (16x16 e.g.)
// layout(local_size_x=32, local_size_y=32, local_size_z=1) in;
layout(local_size_x_id=0, local_size_y_id=1, local_size_z=1) in;

/////////////////////////////////////////////////////////////////////////////////////////
// basic types

struct Plane
{
  vec3 N; // Plane normal
  float d; // Distance to origin
};

// the back and/or front planes can be computed from min/max depth values from fragments within this group 
struct Frustum
{
  Plane planes[6]; // left,right,top,bottom frustum planes
};

/////////////////////////////////////////////////////////////////////////////////////////
// input/output

layout(std140, set=0, binding=0) uniform UBO
{
  mat4 proj_inv;
  uvec2 grid_size; 
} ubo;

// output sbo
layout(std140, set=1, binding=0) buffer TileFrustums
{
  Frustum frustums[];
} sbo;

// p is in view space (counter-clock wise)
//            p2
//           /|\ 
//         /  | |
//       /\   | |
//     /      | |
//  p0|-->  <-|*|   ----> +z-axis
//     \      | |
//       \/   | |
//         \  | |
//           \|/
//            p1
Plane plane_from_p(vec3 p0, vec3 p1, vec3 p2)
{
  Plane ret;

  vec3 v0 = p1 - p0; // p0 >> p1
  vec3 v2 = p2 - p0; // p0 >> p2

  ret.N = normalize(cross(v0,v2));

  // compute the distance to the origin using p0
  ret.d = dot(ret.N, p0);
  return ret;
}

vec3 view_from_ndc(vec3 p, mat4 proj_inv)
{
  vec4 ret = proj_inv * vec4(p.xyz, 1.0);
  return ret.xyz / ret.w;
}

void main()
{
  uvec2 xy = gl_GlobalInvocationID.xy;
  uint tile_count = ubo.grid_size.x * ubo.grid_size.y;
  uint tile_idx = uint(xy.y * ubo.grid_size.x) + xy.x;

  if(xy.x < ubo.grid_size.x && xy.y < ubo.grid_size.y)
  {
    // view space eye position is always at the origin
    vec3 eye = vec3(0,0,0);

    vec2 step = 1.f / ubo.grid_size;
    vec2 pct = xy * step;

    vec3 tl = vec3(mix(-1,1,pct.x), mix(-1,1,pct.y), 0); // top-left
    vec3 tr = vec3(mix(-1,1,pct.x+step.x), mix(-1,1,pct.y), 0); // top-right
    vec3 bl = vec3(mix(-1,1,pct.x), mix(-1,1,pct.y+step.y), 0); // bottom-left
    vec3 br = vec3(mix(-1,1,pct.x+step.x), mix(-1,1,pct.y+step.y), 0); // bottom-right

    // ndc to view space
    tl = view_from_ndc(tl, ubo.proj_inv);
    tr = view_from_ndc(tr, ubo.proj_inv);
    bl = view_from_ndc(bl, ubo.proj_inv);
    br = view_from_ndc(br, ubo.proj_inv);

    sbo.frustums[tile_idx].planes[0] = plane_from_p(eye, tl, bl); // left plane
    sbo.frustums[tile_idx].planes[1] = plane_from_p(eye, br, tr); // right plane
    sbo.frustums[tile_idx].planes[2] = plane_from_p(eye, tr, tl); // top plane
    sbo.frustums[tile_idx].planes[3] = plane_from_p(eye, bl, br); // bottom plane
  }
}
